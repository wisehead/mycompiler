1.词法，语法，语义，代码生成。编译四个步骤。

2.词法分析
关键概念：有限自动机。
输入高级语言，产出：token。

3.语法分析
关键概念：抽象语法树AST。
主要文法分析算法：自顶向下的LL(1)分析，也有自底向上的算符优先分析和LR分析。
书中使用的是LL(1)分析。自顶向下，递归，前序方式构造树。

4.符号表管理
符号表是记录符号信息的数据结构，它使用按名存取的方式记录于符号相关的所有编译信息。
符号存在两种形式：变量和函数。
符号表必须考虑代码作用域的变化。

5.语义分析
语言的文法分为0型、1型、2型、3型文法。3型文法称为正规文法，词法分析器中有限自动机能处理的语法文法就是3型文法。
2型文法也称为上下文无关文法，也是目前计算机程序语言所采用的文法。

实际情况是：程序语言的语句虽然形式上是上下文无关的，但含义上却是上下文相关的。语义分析就是用于弥补这些不足。

语义分析处理下列问题：
（1）变量及函数在使用前是否定义。
（2）break语句是否出现在循环或者switch-case语句内部。
（3）continue语句是否出现在循环语句内部。
（4）return语句返回值的类型是否与函数返回值类型兼容。
（5）函数调用时，实参列表和形参列表是否兼容？
（6）表达式计算及赋值时，类型是否兼容？

语义分析是编译器处理流程中对源代码正确性的最后一次检查。

6.代码生成
（1）表达式的翻译
（2）复合语句的翻译
（3）函数定义与调用的翻译
（4）数据段信息的翻译。

7.编译优化
现代编译器设计分为前端，优化器和后端三大部分，前端包含词法分析、语法分析、和语义分析。
后端的指令选择、指令调度和寄存器分配实际完成代码生成的工作
优化器则是对中间代码进行优化操作。

常用优化算法包括：常量传播、冗余消除、复写传播、和死代码消除等经典的编译优化算法。

8.readelf -a hello.o
查看elf文件的内容。

Linux提供了头文件描述。在系统目录/usr/include/elf.h提供的elf.h头文件中描述了标准ELF文件的数据结构的定义，在实现汇编器和连接器的代码中都引用了该头文件。

9.汇编程序设计
主要工作：段表、符号表、重定位表。

10.连接程序的设计
链接程序的工作内容是，把多个可重定位目标文件正确地合并未可执行文件，但链接器不是对文件进行简单的物理合并。
主要三件事：
（1）地址空间分配
（2）符号解析
（3）重定位

11.地址空间分配
在汇编器生成的目标文件内，是无法确定数据段和代码段的虚拟地址的，因此将他们的段地址都设置为0.链接器要为它们分配段的地址。

12.符号解析
如果说地址空间分配是为段指定地址的话，那么符号解析就是为段内的符号指定地址。对于一个汇编文件来说，它内部使用的符号分为两类：一类来自自身定义的符号，称为内部符号。
另一类来自其他文件定义的符号，本地文件只是使用该符号，这类符号称为外部符号。
在重定位目标文件内，符号表记录了符号的所有信息。

13.重定位
重定位从本质上来说就是地址修正。由于目标文件在链接之前不能获取自己所使用符号的虚拟地址信息，因此导致依赖于这些符号的数据定义或者指令信息缺失。汇编器在生成目标文件的时候就记录下所有需要重定位的信息。链接器获取这些重定位信息，并按照重定位信息的含义修改已经生成的代码，使得最终的代码正确、完整。

重定位和符号解析到底是什么关系？？？？

链接器需要清楚几件事：
（1）在哪里修改二进制信息
（2）用什么信息进行修改
（3）按照怎样的方式修改？？
这三个问题反映在重定位中对应的三个参数：重定位地址、重定位符号、重定位类型。

（1）重定位地址
重定位地址在重定位表中没有直接记录，因为在重定位目标文件内，段地址还没有确定下来，它只记录了重定位位置所在段内的偏移，在地址空间分配结束后，我们使用如下公式算出重定位地址：
	重定位地址 = 重定位位置所在段基址 + 重定位位置的段内偏移。

（2）重定位符号记录着被指令或者数据使用的符号信息，比如call指令的目标标签、mov指令使用的变量符号等。在符号解析结束后，重定位符号的地址就已经确定了。

（3）重定位类型决定修改二进制信息的方式，即绝对地址重定位和相对地址重定位。在确定了重定位符号地址和重定位地址后，根据重定位的类型，连接器便可以正确修改重定位地址处的符号地址信息。


